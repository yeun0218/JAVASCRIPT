<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DOM 1</title>
    <script>
        const fnStart = () => { //head 안에 script 있는 상태로 값 표현하고 싶으면
        /*   Node vs. Element   */
        //class 속성이 있으면 css로 접근하는 게 제일 좋아 
        const parent = document.querySelector(".parent");//css접근방식이니까 .parent 로 작성
        console.log(parent); //접근하려는 parent 의 태그 값이 없어 

        console.log(parent.childNodes); //parent안에 있는 모든 노드들 트리가 가지고 있는 모든 요소들 나타내
        // -> Node type
        console.log(parent.children); // element만 가져와 
        // -> Element type

        console.log("--------------------------")

        /*   검색 API   */
        const e1 = document.getElementById('child2'); //id가 있으면 id로 접근
        console.log("e1 : ", e1); 

        const e2 = document.getElementsByTagName("div"); // element만 가져와//id가 있을경우 회색으로 표시되고 id라인애들 한번 더 표시
        console.log("e2 : ", e2);

        //const e3 = document.querySelector("div"); //첫번째로 걸리는 div 가져와 
        //console.log("e3 : ", e3);

        const e3 = document.querySelector(".child"); // 첫번째로 걸리는 애 하나만 class=child 여러개지만
        console.log("e3 : ", e3);

        const e4 = document.querySelector("#child2"); // id속성인 애 불러올때 
        console.log("e4 : ", e4);

        const e5 = document.querySelector(".child:nth-child(2)"); //2번째 classchild 불러오고싶을때 
        //last-child 쓰거나 nth-child()써도 돼
        console.log("e5 : ", e5);

        console.log("--------------------------")

        const e6 = document.querySelectorAll(".child"); //[]로 묶어서 배열(array)타입으로 ->순서로(index) 접근
        // .child태그 안에 있는 요소들만
         console.log("e6 : ", e6);
         console.log("e6 : ",e6[1].textContent); //index 번호로도 호출 할 수 있어(selectorall로 했을때)
         //index가 0부터시작하기때문에 [1]넣으면 2로 출력
        
        for(let cnt=0; cnt<2; cnt++){ // 배열이여서 반복문으로도 불러오기 가능 (0-> 1-> 2->...순서대로 진행되기 때문에)
            console.log(e6[cnt].textContent);}
        for(let cnt=0; cnt<e6.length; cnt++){ //length : 배열의 갯수를 알려주는 객체(return값 받는애).length
              console.log(e6[cnt].textContent);}

        //for(let item of e6){
        //    console.log(item.textContent);} //배열 데이터 반복문일때 간결하게 표현 가능
        //    for...of 루프 사용하여 -> let item of 객체 : 객체의 각 요소를 순회

        e6.forEach(function(arr){ // 반복문을 함수로 사용하기 가능 arr(매개변수) 데이터 갯수만큼 반복돌아
            console.log(arr.textContent)});  // 반복될때마다 매개변수가 받아서 
        // foreach안에 인자값은 함수로 들어가야해(보통 무명함수 사용 한번쓸꺼니까)
        //e6.forEach(arr=>{console.log(arr.textContent)}); //화살표함수로
        
        console.log("--------------------------")

        const e7 = document.querySelector(".child");
        console.log("e7: ", e7)
        console.log("e7: ", e7.parentElement); //child의 부모로 접근
     
        console.log("e7: ", e7.closest('div')); //제일 가까운 태그 찾을때
        
        console.log("--------------------------")

        console.log("e7: ", e7.previousSibling); //<!--주석-->다음에 엔터 다음에 div여서 공백으로인식
        //previousSibling 은 텍스트노드 포함 (공백도 텍스트노드로 나타남)
        console.log("e7: ", e7.nextSibling);
        console.log("e7: ", e7.previousSibling.parentElement);// 체이닝방식 . 을이용해서 연결해나가는
        console.log("e7: ", e7.parentElement.children);//엘리먼트만 가져와 (태그)노즈요소제외

        console.log("--------------------------")

        console.log("e7: ", e7.previousElementSibling); //앞에 태그요소가 없고 다 노즈요소(sibling이라서 부모는 포함안돼)
        console.log("e7: ", e7.nextElementSibling); //다음에 나타나는 엘리멘트 형제 요소 
        //id 속성은 회색으로 표현되고 id속성안에 있던 애들 한번 더 나타내줘 

        console.log("e7: ", e7.parentElement.firstElementChild);
        console.log("e7: ", e7.parentElement.lastElementChild);
    
        }
    </script>
    
</head>
<body onload="fnStart()"><!--바디안에 있는 애들이 모두다 메모리에 올라갔을때 (모두 만들어져서 실행준비가 끝났다면)-->
    <div class = "parent">
        <!--주석-->
        <div class="child">1</div>
        텍스트1
        <div id="child2" class="child">2</div>
        텍스트2
    </div>
    
</body>
</html>